{"hierarchy":{"paths":[["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs"]]},"identifier":{"url":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree","interfaceLanguage":"swift"},"metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DiameterOfBinaryTree"}],"color":{"standardColorIdentifier":"green"},"navigatorTitle":[{"text":"DiameterOfBinaryTree","kind":"identifier"}],"externalID":"s:12LeetCodeDocs20DiameterOfBinaryTreeV","roleHeading":"Structure","title":"DiameterOfBinaryTree","role":"symbol","symbolKind":"struct","modules":[{"name":"LeetCodeDocs"}]},"schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"text":"LeetCode #543 • Easy • Trees (DFS)","type":"text"}],"topicSections":[{"title":"Classes","anchor":"Classes","generated":true,"identifiers":["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree\/TreeNode"]}],"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"DiameterOfBinaryTree"}]}]},{"content":[{"text":"Overview","anchor":"overview","level":2,"type":"heading"},{"inlineContent":[{"text":"Diameter of Binary Tree","type":"text"}],"type":"paragraph"},{"text":"Intuition","anchor":"Intuition","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Instead of using a global variable, we use a bottom-up DFS that returns a tuple: "},{"code":"(Height, Diameter)","type":"codeVoice"},{"text":". The diameter at any specific node is the sum of the Left Height + Right Height. We bubble up the max diameter found so far.","type":"text"}],"type":"paragraph"},{"type":"thematicBreak"},{"type":"heading","level":2,"anchor":"Complexity-Analysis","text":"Complexity Analysis"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Time Complexity","type":"text"}],"type":"strong"},{"text":": ","type":"text"},{"code":"O(N)","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Space Complexity","type":"text"}],"type":"strong"},{"text":": ","type":"text"},{"type":"codeVoice","code":"O(H)"}]}]}]},{"type":"thematicBreak"},{"text":"Solution","anchor":"Solution","type":"heading","level":2},{"type":"codeListing","syntax":"swift","code":["public class TreeNode {","    public var val: Int","    public var left: TreeNode?","    public var right: TreeNode?","    public init() { self.val = 0; self.left = nil; self.right = nil; }","    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }","    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { self.val = val; self.left = left; self.right = right; }","}","","class Solution {","    func diameterOfBinaryTree(_ root: TreeNode?) -> Int {","        return recursiveHelpers(root).diameter","    }","","    \/\/ Returns (height, diameter)","    private func recursiveHelpers(_ node: TreeNode?) -> (height: Int, diameter: Int) {","        guard let node = node else { return (0, 0) }","","        let left = recursiveHelpers(node.left)","        let right = recursiveHelpers(node.right)","","        let currentHeight = max(left.height, right.height) + 1","        let pathThroughRoot = left.height + right.height","        let currentDiameter = max(pathThroughRoot, left.diameter, right.diameter)","","        return (currentHeight, currentDiameter)","    }","}"]}],"kind":"content"}],"seeAlsoSections":[{"anchor":"Trees-DFS","title":"Trees (DFS)","identifiers":["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/MaximumDepthOfBinaryTree","doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree"],"generated":true}],"variants":[{"paths":["\/documentation\/leetcodedocs\/diameterofbinarytree"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","sections":[],"references":{"doc://LeetCodeDocs/documentation/LeetCodeDocs/DiameterOfBinaryTree":{"kind":"symbol","navigatorTitle":[{"text":"DiameterOfBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree","url":"\/documentation\/leetcodedocs\/diameterofbinarytree","type":"topic","abstract":[{"text":"LeetCode #543 • Easy • Trees (DFS)","type":"text"}],"title":"DiameterOfBinaryTree","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"DiameterOfBinaryTree","kind":"identifier"}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs":{"title":"LeetCodeDocs","type":"topic","identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs","url":"\/documentation\/leetcodedocs","role":"collection","kind":"symbol","abstract":[{"type":"text","text":"My collection of Swift solutions for LeetCode problems, focusing on optimization, time complexity, and language features."}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs/DiameterOfBinaryTree/TreeNode":{"role":"symbol","abstract":[{"text":"Solves the Diameter of Binary Tree problem.","type":"text"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TreeNode"}],"type":"topic","url":"\/documentation\/leetcodedocs\/diameterofbinarytree\/treenode","title":"DiameterOfBinaryTree.TreeNode","kind":"symbol","navigatorTitle":[{"text":"TreeNode","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree\/TreeNode"},"doc://LeetCodeDocs/documentation/LeetCodeDocs/MaximumDepthOfBinaryTree":{"kind":"symbol","navigatorTitle":[{"text":"MaximumDepthOfBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/MaximumDepthOfBinaryTree","url":"\/documentation\/leetcodedocs\/maximumdepthofbinarytree","type":"topic","abstract":[{"type":"text","text":"LeetCode #104 • Easy • Trees (DFS)"}],"title":"MaximumDepthOfBinaryTree","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MaximumDepthOfBinaryTree"}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs/InvertBinaryTree":{"role":"symbol","url":"\/documentation\/leetcodedocs\/invertbinarytree","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"InvertBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree","navigatorTitle":[{"text":"InvertBinaryTree","kind":"identifier"}],"kind":"symbol","type":"topic","title":"InvertBinaryTree","abstract":[{"type":"text","text":"LeetCode #226 • Easy • Trees (DFS)"}]}}}