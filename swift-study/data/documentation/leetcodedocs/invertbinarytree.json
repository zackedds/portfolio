{"primaryContentSections":[{"declarations":[{"languages":["swift"],"tokens":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"InvertBinaryTree","kind":"identifier"}],"platforms":["macOS"]}],"kind":"declarations"},{"kind":"content","content":[{"text":"Overview","level":2,"type":"heading","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Invert Binary Tree"}]},{"type":"heading","text":"Intuition","level":2,"anchor":"Intuition"},{"inlineContent":[{"type":"text","text":"This is a recursive tree problem. At every node, the operation is simple: swap the left and right children. We use the concise Swift "},{"type":"strong","inlineContent":[{"type":"text","text":"Tuple Swap"}]},{"type":"text","text":" syntax "},{"code":"(a, b) = (b, a)","type":"codeVoice"},{"type":"text","text":" for a clean operation, then recursively apply the inversion to both the new left and new right children."}],"type":"paragraph"},{"type":"thematicBreak"},{"anchor":"Complexity-Analysis","text":"Complexity Analysis","level":2,"type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Time Complexity"}]},{"type":"text","text":": "},{"code":"O(N)","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Space Complexity","type":"text"}],"type":"strong"},{"type":"text","text":": "},{"code":"O(H)","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"text":"Solution","anchor":"Solution","type":"heading","level":2},{"type":"codeListing","syntax":"swift","code":["public class TreeNode {","    public var val: Int","    public var left: TreeNode?","    public var right: TreeNode?","    public init() { self.val = 0; self.left = nil; self.right = nil; }","    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }","    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { self.val = val; self.left = left; self.right = right; }","}","","public class Solution {","    func invertTree(_ root: TreeNode?) -> TreeNode? {","        guard let node = root else { return nil }","        (node.left, node.right) = (node.right, node.left)","        invertTree(node.left)","        invertTree(node.right)","        return node","    }","}"]}]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree"},"hierarchy":{"paths":[["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs"]]},"abstract":[{"type":"text","text":"LeetCode #226 • Easy • Trees (DFS)"}],"metadata":{"symbolKind":"struct","modules":[{"name":"LeetCodeDocs"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"InvertBinaryTree"}],"title":"InvertBinaryTree","externalID":"s:12LeetCodeDocs16InvertBinaryTreeV","role":"symbol","roleHeading":"Structure","navigatorTitle":[{"kind":"identifier","text":"InvertBinaryTree"}],"color":{"standardColorIdentifier":"green"}},"variants":[{"paths":["\/documentation\/leetcodedocs\/invertbinarytree"],"traits":[{"interfaceLanguage":"swift"}]}],"seeAlsoSections":[{"title":"Trees (DFS)","identifiers":["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/MaximumDepthOfBinaryTree","doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree"],"anchor":"Trees-DFS","generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"symbol","topicSections":[{"anchor":"Classes","generated":true,"identifiers":["doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree\/Solution","doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree\/TreeNode"],"title":"Classes"}],"references":{"doc://LeetCodeDocs/documentation/LeetCodeDocs/InvertBinaryTree/TreeNode":{"role":"symbol","navigatorTitle":[{"text":"TreeNode","kind":"identifier"}],"url":"\/documentation\/leetcodedocs\/invertbinarytree\/treenode","kind":"symbol","type":"topic","abstract":[{"text":"Solves the Invert Binary Tree problem.","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TreeNode","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree\/TreeNode","title":"InvertBinaryTree.TreeNode"},"doc://LeetCodeDocs/documentation/LeetCodeDocs/DiameterOfBinaryTree":{"role":"symbol","abstract":[{"type":"text","text":"LeetCode #543 • Easy • Trees (DFS)"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DiameterOfBinaryTree"}],"title":"DiameterOfBinaryTree","type":"topic","url":"\/documentation\/leetcodedocs\/diameterofbinarytree","kind":"symbol","navigatorTitle":[{"text":"DiameterOfBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/DiameterOfBinaryTree"},"doc://LeetCodeDocs/documentation/LeetCodeDocs/MaximumDepthOfBinaryTree":{"kind":"symbol","navigatorTitle":[{"text":"MaximumDepthOfBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/MaximumDepthOfBinaryTree","url":"\/documentation\/leetcodedocs\/maximumdepthofbinarytree","type":"topic","abstract":[{"type":"text","text":"LeetCode #104 • Easy • Trees (DFS)"}],"title":"MaximumDepthOfBinaryTree","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MaximumDepthOfBinaryTree"}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs/InvertBinaryTree/Solution":{"title":"InvertBinaryTree.Solution","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Solution","kind":"identifier"}],"url":"\/documentation\/leetcodedocs\/invertbinarytree\/solution","identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree\/Solution","role":"symbol","kind":"symbol","abstract":[],"navigatorTitle":[{"text":"Solution","kind":"identifier"}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs/InvertBinaryTree":{"role":"symbol","url":"\/documentation\/leetcodedocs\/invertbinarytree","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"InvertBinaryTree","kind":"identifier"}],"identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs\/InvertBinaryTree","navigatorTitle":[{"text":"InvertBinaryTree","kind":"identifier"}],"kind":"symbol","type":"topic","title":"InvertBinaryTree","abstract":[{"type":"text","text":"LeetCode #226 • Easy • Trees (DFS)"}]},"doc://LeetCodeDocs/documentation/LeetCodeDocs":{"title":"LeetCodeDocs","type":"topic","identifier":"doc:\/\/LeetCodeDocs\/documentation\/LeetCodeDocs","url":"\/documentation\/leetcodedocs","role":"collection","kind":"symbol","abstract":[{"type":"text","text":"My collection of Swift solutions for LeetCode problems, focusing on optimization, time complexity, and language features."}]}}}